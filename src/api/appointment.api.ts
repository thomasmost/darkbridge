import Koa from 'koa';
import Router from 'koa-router';
import { addMinutes, format } from 'date-fns';
import {
  Appointment,
  AppointmentCreationAttributes,
} from '../models/appointment.model';
import { getById } from './base.api';
import { TeddyRequestContext } from './types';
import { ClientProfile } from '../models/client_profile.model';
import { Op, col } from 'sequelize';
import sequelize from 'sequelize';

// import { WhereAttributeHash } from 'sequelize/types';
// import {
//   Appointment,
//   AppointmentAttributes,
// } from '../models/appointment.model';

export const appointmentAPI = new Router();

export async function getDailyInfo(ctx: Koa.ParameterizedContext) {
  const appointments = [
    {
      id: 'foo',
      status: 'complete',
      datetime_local: '2020-02-04 0:30:00',
      datetime_utc: '2020-02-04 5:30:00',
      duration: 60,
    },
    {
      id: 'bar',
      status: 'scheduled',
      datetime_local: '2020-02-04 10:30:00',
      datetime_utc: '2020-02-04 15:30:00',
      duration: 60,
    },
    {
      id: 'baz',
      status: 'scheduled',
      datetime_local: '2020-02-04 15:00:00',
      datetime_utc: '2020-02-04 20:00:00',
      duration: 90,
    },
  ];

  ctx.status = 200;

  const countAppointments = appointments.length;

  if (countAppointments === 0) {
    ctx.body = {
      appointments,
      nextAppointment: null,
      summary: `Looks like you don't have any appointments today. Time to kick back! (Alternatively, you can head over to your Calendar to add a new job)`,
    };
    return;
  }
  const lastAppointment = appointments[countAppointments - 1];
  const lastAppointmentDate = new Date(lastAppointment.datetime_local);
  const doneBy = new Date(lastAppointment.datetime_local);
  doneBy.setMinutes(
    lastAppointmentDate.getMinutes() + lastAppointment.duration,
  );
  let completed = 0;
  let nextAppointment = null;
  for (const appointment of appointments) {
    if (appointment.status === 'complete') {
      completed++;
    }
    if (appointment.status === 'scheduled' && nextAppointment === null) {
      nextAppointment = appointment;
    }
  }
  if (completed === 0) {
    ctx.body = {
      appointments,
      nextAppointment,
      summary: `Today you have ${countAppointments} appointments, within a 15 mile radius. You should be done by ${doneBy}.`,
    };
    return;
  }
  ctx.body = {
    appointments,
    nextAppointment,
    summary: `Today you have ${countAppointments} appointments, within a 15 mile radius. You've already knocked out ${completed}! You should be done by ${format(
      doneBy,
      'h:ma',
    )} this evening.`,
  };
}

appointmentAPI.get('/daily', getDailyInfo);

export async function getAppointments(ctx: Koa.ParameterizedContext) {
  ctx.body = [];
  ctx.status = 200;
}

appointmentAPI.get('/', getAppointments);

appointmentAPI.get('/:id', getById(Appointment));

export async function createAppointment(ctx: TeddyRequestContext) {
  if (!ctx.user) {
    ctx.status = 401;
    return;
  }

  const {
    client_profile_id,
    datetime_local,
    duration_minutes,
    priority,
    summary,
  } = ctx.request.body as AppointmentCreationAttributes;

  if (!duration_minutes) {
    throw Error('400');
  }

  const client_profile = await ClientProfile.findByPk(client_profile_id);
  if (!client_profile) {
    throw Error(`Client with id ${client_profile_id} not found`);
  }

  const datetime_end_local = addMinutes(
    new Date(datetime_local),
    duration_minutes,
  ).toString();

  const timezone = client_profile.timezone;

  const datetime_utc = new Date(datetime_local).toUTCString();
  const datetime_end_utc = new Date(datetime_end_local).toUTCString();

  const {
    address_street,
    address_city,
    address_state,
    address_postal_code,
  } = client_profile;

  const conflictingAppointments = await Appointment.findAll({
    where: {
      [Op.or]: [
        {
          datetime_utc: {
            [Op.gte]: datetime_utc,
            [Op.lte]: datetime_end_utc,
          },
        },
        {
          datetime_end_utc: {
            [Op.gte]: datetime_utc,
            [Op.lte]: datetime_end_utc,
          },
        },
      ],
    },
  });

  if (conflictingAppointments.length) {
    throw Error('Existing appointments conflict with this one');
  }

  // for now, appointments can only be generated by the service providers
  const service_provider_user_id = ctx.user.id;

  const appointment = await Appointment.create({
    client_profile_id,
    datetime_local: datetime_local.substring(0, 24) + ' GMT',
    datetime_utc,
    datetime_end_local: datetime_end_local.substring(0, 24) + ' GMT',
    datetime_end_utc,
    service_provider_user_id,
    summary,
    address_street,
    address_city,
    address_state,
    address_postal_code,
    timezone,
    priority,
  });

  ctx.body = appointment;
  ctx.status = 200;
}

appointmentAPI.post('/', createAppointment);

export async function cancelAppointment(ctx: TeddyRequestContext) {
  if (!ctx.user) {
    ctx.status = 401;
    return;
  }
  const user = ctx.user;

  const id = ctx.params.id;
  const appointment = await Appointment.findByPk(id);

  // If either the appointment doesn't exist or doesn't belong to the logged in user, 404
  if (!appointment || appointment.service_provider_user_id !== user.id) {
    ctx.status = 404;
    return;
  }
  appointment.status = 'canceled';
  await appointment.save();
  ctx.status = 204;
}

appointmentAPI.put('/:id/cancel', cancelAppointment);

export async function rateServiceOnAppointment(ctx: TeddyRequestContext) {
  const { rating } = ctx.request.body as { rating: number };

  const id = ctx.params.id;
  const appointment = await Appointment.findByPk(id);

  // If the appointment doesn't exist, 404
  if (!appointment) {
    ctx.status = 404;
    return;
  }
  if (appointment.rating_of_service) {
    throw Error('appointment service has already been rated');
  }
  appointment.rating_of_service = rating;
  await appointment.save();
  ctx.status = 204;
}

appointmentAPI.put('/:id/rate_service', rateServiceOnAppointment);

export async function rateClientOnAppointment(ctx: TeddyRequestContext) {
  if (!ctx.user) {
    ctx.status = 401;
    return;
  }
  const { rating } = ctx.request.body as { rating: number };
  const user = ctx.user;

  const id = ctx.params.id;
  const appointment = await Appointment.findByPk(id);

  // If either the appointment doesn't exist or doesn't belong to the logged in user, 404
  if (!appointment || appointment.service_provider_user_id !== user.id) {
    ctx.status = 404;
    return;
  }
  appointment.rating_of_client = rating;
  await appointment.save();
  ctx.status = 204;
}

appointmentAPI.put('/:id/rate_client', rateClientOnAppointment);
